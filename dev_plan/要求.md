# Web 版AI 旅行规划师 (AI Travel Planner)

## 一、说明：

软件旨在简化旅行规划过程，通过 AI 了解用户需求，自动生成详细的旅行路线和建议，并提供实时旅行辅助。

## 二、核心功能：

1、智能行程规划: 用户可以通过语音（或文字，语音功能一定要有）输入旅行目的地、日期、预算、同行人数、旅行偏好（例如：“我想去日本，5 天，预算 1 万元，喜欢美食和动漫，带孩子”），AI 会自动生成个性化的旅行路线，包括交通、住宿、景点、餐厅等详细信息。

2、费用预算与管理: 由 AI 进行预算分析，记录旅行开销（推荐可以使用语音）。

3、用户管理与数据存储:

注册登录系统: 用户可以保存和管理多份旅行计划。

**安全要求**:
- **密码安全**: 使用SRP（Secure Remote Password）协议进行用户认证，服务器不存储用户密码，只存储验证器
- **数据加密**: 行程数据使用用户登录密码进行端到端加密，后端只存储加密数据，前端负责所有加密解密操作
- **API密钥加密**: API密钥使用用户登录密码进行加密存储，使用时由客户端使用登录密码自动解密
- **加密存储设计**:
  - 后端只负责存储加密数据，不处理业务逻辑
  - 前端负责数据加密解密和所有业务逻辑处理
  - 使用用户密码派生密钥进行AES加密
  - 数据在传输和存储过程中始终加密

云端行程同步: 旅行计划、偏好设置、费用记录等数据云端同步，方便多设备查看和修改。

## 三、技术栈（ Web）

语音识别：基于科大讯飞语音识别 API 提供语音识别功能

地图导航：基于高德API 提供地理位置服务和导航功能

数据库/认证：先使用sqlite，待项目发展在更换其他数据库后端。

行程规划和费用预算：通过大语言模型完成形成规划和费用预算的估计

UI/UX： 地图为主的交互界面，清晰的行程展示，美观的图片。

前端：使用React + TypeScript + Vite构建Web前端（注：原计划使用Flutter，实际实现已改为React）

后端：python+fastAPI，python使用uv管理环境。

LLM：使用OpenAI API，默认使用deepseek-chat模型

搜索：使用智谱（GLM）搜索API

注意，所有项目相关的文件（包括环境）请存放到项目目录中。

## 四、具体设计

项目需要先登陆才能使用

注册时要求用户提供LLM、高德、智谱（GLM）搜索API和科大讯飞语音识别的API KEY，但允许为空。API KEY为空时相关服务不可用但不影响其他服务。

**重要：所有API密钥将与用户账户绑定，每个用户只能使用自己设置的API密钥。系统不会使用任何全局或默认的API密钥。**

在账户设置界面，用户可以更改API KEY以及更换LLM URL和model name（这两项默认使用DeepSeek 和DeepSeek-chat）

用户可以手动创建行程，也可以使用AI根据描述生成行程。生成的行程允许手动更改。每个旅行计划由若干个子行程构成，每个子行程需要提供地点、时间（起始和终止）和预计开销。地点需要包含城市名称和国家代码（手动创建时应允许用户通过国家名称设置国家代码）。

使用AI创建行程时，AI根据用户的需求生成json格式的行程安排，其中应该包括本文档的需求需要的内容以及城市名称和国家代码以便地图API使用。如果用户配置了搜索API，AI可以使用工具调用的方式使用搜索API进行详细搜索然后再根据搜索结果创建计划。如果对于某个旅行计划，已经存在了一些行程，则使用AI时应当传入已有行程让AI根据需求修改，否则直接让AI生成完整的行程。AI生成或调整行程之后请务必检查输出的json以及其中内容是否符合要求，不符合则将检查结果（不符合原因）与有问题的json传入AI令其更改。如果已经进行过更改请使用新的更改要求和问题json替换上下文中原有的相应内容。如果使用了搜索，行程相关信息（如地点/耗时/预计开销等）尽量来源于搜索结果。如果配置了搜索API则大模型随时可以使用搜索工具。大模型相关内容尽量放到后端python中，从而便于开发和调试。

预算分析功能应当根据旅行计划中所有子行程的预计开销进行。将所有子行程的信息以及所有子行程预计开销之和（以及可选的需求）传入AI进行分析。如果配置了搜索API，可以让AI以工具调用的方式使用该搜索API。预算分析应当使用人民币进行分析。

本项目的UI暂时只考虑PC以及横屏浏览（即屏幕为长方形）。

主ui应当是一个旅行计划列表，点击某个计划进入该计划的子页面后可以进入查看子行程。UI显示时同一天的子行程应当处于同一个视觉元素中，从而可以直观的看到不同日期的行程。旅行计划子页面中左侧应当为子行程列表，右侧有一个地图（使用高德地图API）这个界面可以切换是否为编辑模式，处于编辑模式下左侧可以手动添加/删除行程以及编辑行程信息。编辑模式下用户可以使用AI规划行程，点击相关按钮之后弹出弹窗让用户输入自己的需求，该弹窗下也有按钮允许用户使用语音输入（基于科大讯飞语音识别 API 提供语音识别功能）。用户点击左侧某个地址之后右侧地图上显示该地址搜索结果的排名靠前的地点。用户可以通过点击选择其中之一，选择后其他地点不再显示（或必须做出明确视觉区分且不能再选择）。如果用户没有选择，则点击其他子行程时地图上显示的地点更新为新选择的子行程地点名称在地图API搜索结果的靠前项。如果用户已经选择了一个地址，则点击其他子行程时被选择的地点应当保留，未被选择的位置消失。被选择的点再次点击后可以取消选择（如果该点不属于目前选中的活动则消失）。界面最右侧应该有一个可以点击呼出或隐藏的窗口。该窗口中一列表形式展示已经被选择的地点，用户可以调整这些地点的顺序并选择交通方式然后生成按照用户调整后顺序连接起这些点的导航方案（如果交通方式下API不支持途径点，则应当说明，并让用户在右侧选择两个（最少也最多两个点，已经选择两个点时如果又选择新的点的弹出提示并拒绝地点被选择；如果只选择了一个点或更少则点击生成导航方案时弹出相应提示）地点然后生成这两个地点之间的导航信息；如果交通方式支持途径点则默认情况下使用所有中间点作为途径点，但也可以手动选择超过两个点然后向API查询按照顺序经过这些点的导航信息），并提供耗时预估。

## 五、API文档

---

# 高德

### 一、准备工作

### 1. 注册开发者账号和获取API Key

首先需要在高德开放平台注册账号，创建应用并获取Web端API Key：

```dart
// 高德地图API Key（需要替换为您的实际Key）
const String AMAP_API_KEY = '您的高德地图Web API Key';
```

### 2. Flutter Web项目配置

在 `pubspec.yaml`中添加必要的依赖：

```yaml
dependencies:
  flutter:
    sdk: flutter
  js: ^0.6.7
  http: ^0.13.6
  geojson: ^1.0.6

dev_dependencies:
  build_web_compilers: ^4.0.0
  build_runner: ^2.4.4
```

## 二、基础地图展示

### 1. 创建HTML容器

在 `web/index.html`中添加地图容器：

```html
<div id="map-container" style="width: 100%; height: 100vh;"></div>
```

### 2. 初始化高德地图

创建Dart与JavaScript的互操作代码：

```dart
// lib/amap_web_api.dart
@JS()
library amap_web_api;

import 'package:js/js.dart';
import 'package:js/js_util.dart';

@JS('AMap')
class AMap {
  external static Map create(String containerId, MapOptions options);
}

@JS()
@anonymous
class MapOptions {
  external factory MapOptions({
    int zoom,
    double centerLng,
    double centerLat,
    bool zoomEnable,
    bool dragEnable,
    bool resizeEnable,
  });
}

@JS()
class Marker {
  external factory Marker(MarkerOptions options);
  external void addTo(Map map);
  external void remove();
  external void on(String eventName, Function callback);
  external void setPosition(LngLat position);
  external void setContent(String content);
}

@JS()
@anonymous
class MarkerOptions {
  external factory MarkerOptions({
    LngLat position,
    String content,
    bool bubble,
    bool cursor,
    bool draggable,
    bool raiseOnDrag,
    bool visible,
    int zIndex,
  });
}

@JS()
class LngLat {
  external factory LngLat(double lng, double lat);
}

@JS()
class InfoWindow {
  external factory InfoWindow(InfoWindowOptions options);
  external void open(Map map, LngLat position);
}

@JS()
@anonymous
class InfoWindowOptions {
  external factory InfoWindowOptions({
    String content,
    int offset,
    bool autoMove,
    bool closeWhenClickMap,
  });
}

// 路线规划相关
@JS()
class Driving {
  external factory Driving(DrivingOptions options);
  external void search(LngLat start, LngLat end, [Function callback]);
}

@JS()
@anonymous
class DrivingOptions {
  external factory DrivingOptions({
    bool map,
    bool panel,
    bool policy,
    bool hideMarkers,
    bool showTraffic,
    double zIndex,
  });
}

@JS()
class Transit {
  external factory Transit(TransitOptions options);
  external void search(LngLat start, LngLat end, [Function callback]);
}

@JS()
@anonymous
class TransitOptions {
  external factory TransitOptions({
    bool map,
    bool panel,
    bool policy,
    bool city,
    bool cityd,
    bool hideMarkers,
    double zIndex,
  });
}

// 搜索服务
@JS()
class PlaceSearch {
  external factory PlaceSearch(PlaceSearchOptions options);
  external void search(String keyword, Function callback);
  external void searchNearBy(String keyword, LngLat center, double radius, Function callback);
}

@JS()
@anonymous
class PlaceSearchOptions {
  external factory PlaceSearchOptions({
    String city,
    int pageSize,
    int pageIndex,
    String type,
    bool map,
    bool panel,
    bool cityLimit,
  });
}

// 初始化地图
void initMap() {
  js.context.callMethod('initAmap', [AMAP_API_KEY]);
}

// Dart端调用
void initializeMap() {
  initMap();
}
```

### 3. 创建JavaScript桥接文件

在 `web/js/amap_bridge.js`中添加：

```javascript
function initAmap(apiKey) {
  // 加载高德地图JS API
  const script = document.createElement('script');
  script.src = `https://webapi.amap.com/maps?v=2.0&key=${apiKey}`;
  script.onload = function() {
    // 初始化地图
    window.map = new AMap.Map('map-container', {
      zoom: 13,
      center: [116.397428, 39.90923],
      zoomEnable: true,
      dragEnable: true,
      resizeEnable: true
    });
  
    // 存储标记点
    window.markers = [];
    window.routes = [];
  
    console.log('高德地图初始化完成');
  };
  document.head.appendChild(script);
}

// 创建标记点
function createMarker(lng, lat, content, clickable = true) {
  const marker = new AMap.Marker({
    position: new AMap.LngLat(lng, lat),
    content: content || '<div style="width:20px;height:20px;background:red;border-radius:50%;"></div>',
    bubble: true,
    cursor: 'pointer',
    draggable: false,
    raiseOnDrag: false,
    visible: true,
    zIndex: 100
  });
  
  if (clickable) {
    marker.on('click', function(e) {
      const infoWindow = new AMap.InfoWindow({
        content: `<div style="padding:10px;">${content || '位置信息'}</div>`,
        offset: new AMap.Pixel(0, -30),
        autoMove: true,
        closeWhenClickMap: true
      });
      infoWindow.open(window.map, marker.getPosition());
    
      // 通知Dart端标记点被点击
      if (window.onMarkerClick) {
        window.onMarkerClick({
          lng: lng,
          lat: lat,
          content: content
        });
      }
    });
  }
  
  marker.addTo(window.map);
  window.markers.push(marker);
  return marker;
}

// 清除所有标记点
function clearMarkers() {
  window.markers.forEach(marker => marker.remove());
  window.markers = [];
}

// 显示/隐藏标记点
function toggleMarkerVisibility(visible) {
  window.markers.forEach(marker => {
    marker.setOptions({ visible: visible });
  });
}

// 创建驾车路线
function createDrivingRoute(startLng, startLat, endLng, endLat, showTraffic = true) {
  const driving = new AMap.Driving({
    map: window.map,
    panel: 'panel',
    policy: AMap.DrivingPolicy.LEAST_TIME,
    hideMarkers: false,
    showTraffic: showTraffic,
    zIndex: 10
  });
  
  const start = new AMap.LngLat(startLng, startLat);
  const end = new AMap.LngLat(endLng, endLat);
  
  driving.search(start, end, function(status, result) {
    if (status === 'complete') {
      // 通知Dart端路线规划完成
      if (window.onRouteComplete) {
        window.onRouteComplete({
          status: 'success',
          distance: result.routes[0].distance,
          time: result.routes[0].time,
          tolls: result.routes[0].tolls
        });
      }
    } else {
      if (window.onRouteComplete) {
        window.onRouteComplete({
          status: 'error',
          message: result
        });
      }
    }
  });
  
  return driving;
}

// 创建公交路线
function createTransitRoute(startLng, startLat, endLng, endLat, city) {
  const transit = new AMap.Transit({
    map: window.map,
    panel: 'panel',
    policy: AMap.TransitPolicy.LEAST_TIME,
    city: city,
    hideMarkers: false,
    zIndex: 10
  });
  
  const start = new AMap.LngLat(startLng, startLat);
  const end = new AMap.LngLat(endLng, endLat);
  
  transit.search(start, end, function(status, result) {
    if (status === 'complete') {
      if (window.onRouteComplete) {
        window.onRouteComplete({
          status: 'success',
          distance: result.routes[0].distance,
          time: result.routes[0].time,
          price: result.routes[0].price
        });
      }
    } else {
      if (window.onRouteComplete) {
        window.onRouteComplete({
          status: 'error',
          message: result
        });
      }
    }
  });
  
  return transit;
}

// 地点搜索（关键字搜索）
function searchPlaces(keyword, city, callback) {
  const placeSearch = new AMap.PlaceSearch({
    city: city || '全国',
    pageSize: 20,
    pageIndex: 1,
    map: window.map,
    panel: 'panel',
    citylimit: true
  });
  
  placeSearch.search(keyword, function(status, result) {
    if (status === 'complete') {
      const pois = result.poiList.pois.map(poi => ({
        id: poi.id,
        name: poi.name,
        address: poi.address,
        location: {
          lng: poi.location.lng,
          lat: poi.location.lat
        },
        type: poi.type
      }));
    
      callback({ status: 'success', results: pois });
    } else {
      callback({ status: 'error', message: result });
    }
  });
}

// 周边搜索
function searchNearby(keyword, centerLng, centerLat, radius, callback) {
  const placeSearch = new AMap.PlaceSearch({
    pageSize: 20,
    pageIndex: 1,
    map: window.map,
    panel: 'panel'
  });
  
  const center = new AMap.LngLat(centerLng, centerLat);
  
  placeSearch.searchNearBy(keyword, center, radius, function(status, result) {
    if (status === 'complete') {
      const pois = result.poiList.pois.map(poi => ({
        id: poi.id,
        name: poi.name,
        address: poi.address,
        location: {
          lng: poi.location.lng,
          lat: poi.location.lat
        },
        type: poi.type,
        distance: poi.distance
      }));
    
      callback({ status: 'success', results: pois });
    } else {
      callback({ status: 'error', message: result });
    }
  });
}
```

### 4. 在Flutter中初始化地图

```dart
import 'dart:js' as js;
import 'package:js/js_util.dart';
import 'package:flutter/material.dart';

class MapPage extends StatefulWidget {
  @override
  _MapPageState createState() => _MapPageState();
}

class _MapPageState extends State<MapPage> {
  // 标记点列表
  List<Map<String, dynamic>> markers = [];
  
  @override
  void initState() {
    super.initState();
    // 初始化地图
    initializeMap();
    // 设置JavaScript回调
    setupJsCallbacks();
  }
  
  void initializeMap() {
    js.context.callMethod('initAmap', [AMAP_API_KEY]);
  }
  
  void setupJsCallbacks() {
    // 设置标记点点击回调
    js.context['onMarkerClick'] = allowInterop((data) {
      setState(() {
        print('标记点被点击: ${data['content']}');
        // 处理标记点点击事件
      });
    });
  
    // 设置路线规划完成回调
    js.context['onRouteComplete'] = allowInterop((data) {
      setState(() {
        if (data['status'] == 'success') {
          print('路线规划成功');
          print('距离: ${data['distance']}米');
          print('时间: ${data['time']}秒');
          if (data.containsKey('price')) {
            print('票价: ${data['price']}元');
          }
          if (data.containsKey('tolls')) {
            print('过路费: ${data['tolls']}元');
          }
        } else {
          print('路线规划失败: ${data['message']}');
        }
      });
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Container(
        width: double.infinity,
        height: double.infinity,
        child: Stack(
          children: [
            // 地图容器
            HtmlElementView(viewType: 'map-container'),
            // 控制面板
            Positioned(
              bottom: 20,
              left: 20,
              right: 20,
              child: Container(
                padding: EdgeInsets.all(10),
                color: Colors.white.withOpacity(0.8),
                child: Column(
                  children: [
                    Row(
                      children: [
                        ElevatedButton(
                          onPressed: () => addTestMarkers(),
                          child: Text('添加测试标记点'),
                        ),
                        SizedBox(width: 10),
                        ElevatedButton(
                          onPressed: () => clearAllMarkers(),
                          child: Text('清除所有标记点'),
                        ),
                        SizedBox(width: 10),
                        ElevatedButton(
                          onPressed: () => toggleMarkersVisibility(),
                          child: Text('切换标记点显示'),
                        ),
                      ],
                    ),
                    SizedBox(height: 10),
                    Row(
                      children: [
                        ElevatedButton(
                          onPressed: () => planDrivingRoute(),
                          child: Text('驾车导航'),
                        ),
                        SizedBox(width: 10),
                        ElevatedButton(
                          onPressed: () => planTransitRoute(),
                          child: Text('公交导航'),
                        ),
                      ],
                    ),
                    SizedBox(height: 10),
                    TextField(
                      decoration: InputDecoration(
                        hintText: '搜索地点',
                        prefixIcon: Icon(Icons.search),
                      ),
                      onSubmitted: (value) => searchPlaces(value),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  void addTestMarkers() {
    // 添加测试标记点
    final testPoints = [
      {'lng': 116.397428, 'lat': 39.90923, 'name': '天安门'},
      {'lng': 116.407395, 'lat': 39.904211, 'name': '王府井'},
      {'lng': 116.388878, 'lat': 39.914602, 'name': '西单'},
    ];
  
    markers = testPoints;
  
    for (var point in testPoints) {
      js.context.callMethod('createMarker', [
        point['lng'],
        point['lat'],
        point['name'],
        true
      ]);
    }
  }
  
  void clearAllMarkers() {
    markers.clear();
    js.context.callMethod('clearMarkers', []);
  }
  
  void toggleMarkersVisibility() {
    final isVisible = markers.isNotEmpty && markers.first['visible'] != false;
    for (var marker in markers) {
      marker['visible'] = !isVisible;
    }
    js.context.callMethod('toggleMarkerVisibility', [!isVisible]);
  }
  
  void planDrivingRoute() {
    if (markers.length >= 2) {
      final start = markers[0];
      final end = markers[1];
      js.context.callMethod('createDrivingRoute', [
        start['lng'], start['lat'],
        end['lng'], end['lat'],
        true
      ]);
    } else {
      print('请先添加至少2个标记点');
    }
  }
  
  void planTransitRoute() {
    if (markers.length >= 2) {
      final start = markers[0];
      final end = markers[1];
      js.context.callMethod('createTransitRoute', [
        start['lng'], start['lat'],
        end['lng'], end['lat'],
        '北京'
      ]);
    } else {
      print('请先添加至少2个标记点');
    }
  }
  
  void searchPlaces(String keyword) {
    js.context.callMethod('searchPlaces', [keyword, '北京', allowInterop((result) {
      if (result['status'] == 'success') {
        setState(() {
          markers = result['results'].map((poi) => {
            'id': poi['id'],
            'name': poi['name'],
            'address': poi['address'],
            'lng': poi['location']['lng'],
            'lat': poi['location']['lat'],
            'type': poi['type'],
            'visible': true
          }).toList();
        
          // 在地图上显示搜索结果
          for (var poi in result['results']) {
            js.context.callMethod('createMarker', [
              poi['location']['lng'],
              poi['location']['lat'],
              poi['name'],
              true
            ]);
          }
        });
      } else {
        print('搜索失败: ${result['message']}');
      }
    })]);
  }
}
```

## 三、具体功能实现

### 1. 地点搜索功能

```dart
// 根据地点名称、城市名称搜索
Future<List<Map<String, dynamic>>> searchLocation({
  required String keyword,
  String? city,
  String? country,
}) async {
  final completer = Completer<List<Map<String, dynamic>>>();
  
  js.context.callMethod('searchPlaces', [
    keyword,
    city ?? '全国',
    allowInterop((result) {
      if (result['status'] == 'success') {
        completer.complete(result['results']);
      } else {
        completer.completeError(result['message']);
      }
    })
  ]);
  
  return completer.future;
}

// 周边搜索（根据中心点和半径）
Future<List<Map<String, dynamic>>> searchNearby({
  required String keyword,
  required double centerLng,
  required double centerLat,
  double radius = 1000, // 1公里
}) async {
  final completer = Completer<List<Map<String, dynamic>>>();
  
  js.context.callMethod('searchNearby', [
    keyword,
    centerLng,
    centerLat,
    radius,
    allowInterop((result) {
      if (result['status'] == 'success') {
        completer.complete(result['results']);
      } else {
        completer.completeError(result['message']);
      }
    })
  ]);
  
  return completer.future;
}
```

### 2. 地图标记点管理

```dart
// 添加标记点
void addMarker({
  required double lng,
  required double lat,
  String? content,
  bool clickable = true,
  bool visible = true,
}) {
  js.context.callMethod('createMarker', [
    lng,
    lat,
    content ?? '<div style="width:20px;height:20px;background:red;border-radius:50%;"></div>',
    clickable
  ]);
  
  markers.add({
    'lng': lng,
    'lat': lat,
    'content': content,
    'visible': visible
  });
}

// 清除所有标记点
void clearAllMarkers() {
  js.context.callMethod('clearMarkers', []);
  markers.clear();
}

// 调整标记点显示
void setMarkerVisibility(bool visible) {
  js.context.callMethod('toggleMarkerVisibility', [visible]);
  for (var marker in markers) {
    marker['visible'] = visible;
  }
}

// 自定义标记点样式
void customizeMarkerStyle({
  required int index,
  String? content,
  String? color,
  double? size,
}) {
  if (index < markers.length) {
    final marker = markers[index];
    final newContent = content ?? 
      '<div style="width:${size ?? 20}px;height:${size ?? 20}px;background:${color ?? 'red'};border-radius:50%;"></div>';
  
    // 需要重新创建标记点，高德JS API不支持直接修改样式
    js.context.callMethod('clearMarkers', []);
    markers.forEach((m) {
      js.context.callMethod('createMarker', [
        m['lng'],
        m['lat'],
        m == marker ? newContent : m['content'],
        true
      ]);
    });
  }
}
```

### 3. 路线规划与导航

```dart
// 驾车路线规划
Future<Map<String, dynamic>> planDrivingRoute({
  required List<Map<String, dynamic>> waypoints,
  bool showTraffic = true,
}) async {
  if (waypoints.length < 2) {
    throw Exception('至少需要2个途经点');
  }
  
  final completer = Completer<Map<String, dynamic>>();
  
  // 高德JS API的Driving支持多个途经点
  js.context.callMethod('createDrivingRouteWithWaypoints', [
    waypoints.map((w) => w['lng']).toList(),
    waypoints.map((w) => w['lat']).toList(),
    showTraffic,
    allowInterop((result) {
      if (result['status'] == 'complete') {
        completer.complete({
          'status': 'success',
          'distance': result['routes'][0]['distance'],
          'time': result['routes'][0]['time'],
          'tolls': result['routes'][0]['tolls'],
          'steps': result['routes'][0]['steps']
        });
      } else {
        completer.completeError(result['message']);
      }
    })
  ]);
  
  return completer.future;
}

// 公共交通路线规划
Future<Map<String, dynamic>> planTransitRoute({
  required Map<String, dynamic> start,
  required Map<String, dynamic> end,
  String city = '北京',
}) async {
  final completer = Completer<Map<String, dynamic>>();
  
  js.context.callMethod('createTransitRoute', [
    start['lng'],
    start['lat'],
    end['lng'],
    end['lat'],
    city,
    allowInterop((result) {
      if (result['status'] == 'complete') {
        completer.complete({
          'status': 'success',
          'distance': result['routes'][0]['distance'],
          'time': result['routes'][0]['time'],
          'price': result['routes'][0]['price'],
          'segments': result['routes'][0]['segments']
        });
      } else {
        completer.completeError(result['message']);
      }
    })
  ]);
  
  return completer.future;
}

// 多点路线规划（满足顺序要求）
Future<Map<String, dynamic>> planSequentialRoute({
  required List<Map<String, dynamic>> points,
  String transportMode = 'driving', // driving, transit, walking
}) async {
  if (points.length < 2) {
    throw Exception('至少需要2个点');
  }
  
  final results = <Map<String, dynamic>>[];
  double totalDistance = 0;
  double totalTime = 0;
  
  for (var i = 0; i < points.length - 1; i++) {
    final start = points[i];
    final end = points[i + 1];
  
    if (transportMode == 'driving') {
      final result = await planDrivingRoute(
        waypoints: [start, end],
        showTraffic: true
      );
      results.add(result);
      totalDistance += result['distance'];
      totalTime += result['time'];
    } else if (transportMode == 'transit') {
      final result = await planTransitRoute(
        start: start,
        end: end,
        city: '北京'
      );
      results.add(result);
      totalDistance += result['distance'];
      totalTime += result['time'];
    }
  }
  
  return {
    'status': 'success',
    'total_distance': totalDistance,
    'total_time': totalTime,
    'segments': results
  };
}
```

### 4. 事件处理

```dart
// 处理地图点击事件
void setupMapClickHandler() {
  js.context['onMapClick'] = allowInterop((data) {
    setState(() {
      print('地图被点击位置: ${data['lng']}, ${data['lat']}');
      // 可以在这里添加标记点或执行其他操作
    });
  });
}

// 处理标记点点击事件
void setupMarkerClickHandler(Function(Map<String, dynamic>) callback) {
  js.context['onMarkerClick'] = allowInterop((data) {
    callback({
      'lng': data['lng'],
      'lat': data['lat'],
      'content': data['content']
    });
  });
}

// 处理路线规划完成事件
void setupRouteCompleteHandler(Function(Map<String, dynamic>) callback) {
  js.context['onRouteComplete'] = allowInterop((data) {
    callback(data);
  });
}
```

## 四、限制和注意事项

### 1. 无法完全实现的功能

- **高德地图Flutter Web SDK**：高德官方没有提供专门的Flutter Web SDK，需要通过JavaScript API桥接实现
- **实时交通数据**：在Web端获取实时交通数据需要额外的API调用和权限
- **离线地图**：Flutter Web无法实现离线地图功能
- **3D地图**：Web端的3D地图功能有限，不如原生SDK强大

### 2. 高德地图API限制

- **调用频率限制**：免费版有调用次数限制，需要申请企业版获取更高配额
- **并发限制**：同一时间只能规划一条路线
- **跨域问题**：在Web环境下需要注意CORS问题

### 3. 性能优化建议

```dart
// 1. 懒加载地图
void loadMapWhenNeeded() {
  if (!isMapLoaded) {
    initializeMap();
    isMapLoaded = true;
  }
}

// 2. 批量操作标记点
void batchUpdateMarkers(List<Map<String, dynamic>> newMarkers) {
  js.context.callMethod('clearMarkers', []);
  for (var marker in newMarkers) {
    js.context.callMethod('createMarker', [
      marker['lng'],
      marker['lat'],
      marker['content'],
      true
    ]);
  }
  markers = newMarkers;
}

// 3. 使用节流函数
void throttleSearch(String keyword) {
  if (_searchTimer != null) {
    _searchTimer!.cancel();
  }
  
  _searchTimer = Timer(const Duration(milliseconds: 300), () {
    searchPlaces(keyword);
  });
}
```

## 五、完整示例代码

```dart
import 'dart:async';
import 'dart:js' as js;
import 'package:flutter/material.dart';
import 'package:js/js.dart';
import 'package:js/js_util.dart';

const String AMAP_API_KEY = 'YOUR_AMAP_API_KEY';

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: '高德地图Flutter Web Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: MapPage(),
    );
  }
}

// 以下是完整的MapPage类实现，包含所有功能
// ...（上面已经展示的部分代码）
```

## 六、总结

通过以上实现，您可以在Flutter Web应用中完整使用高德地图API的功能，包括：

- ✅ 根据地点名称、城市名称搜索地点
- ✅ 在Flutter Web上展示地图
- ✅ 在地图上显示可点击的地点
- ✅ 获取用户点击选择的地点
- ✅ 调整地图上点的显示与否和显示方式
- ✅ 根据交通方式和地点列表进行导航规划
- ✅ 获取导航预计时间开销
- ✅ 在地图上显示导航路线

**无法完全实现的功能**：

- 高德官方没有提供纯Web API的导航路线绘制功能，需要依赖JavaScript API
- 公共交通的详细换乘信息在免费版中可能有限制
- 实时交通数据的获取需要企业级权限

建议在实际项目中：

1. 申请企业级高德地图API Key获取更高配额
2. 实现错误处理和用户体验优化
3. 考虑使用缓存减少API调用次数
4. 针对不同设备进行响应式设计优化

这份文档提供了完整的代码实现和详细说明，您可以根据实际需求进行调整和扩展。

---



# 科大讯飞语音识别

## 一、准备工作

### 1. 注册科大讯飞账号

- 访问科大讯飞开放平台（https://www.xfyun.cn/）注册账号
- 创建应用并获取APPID、APISecret、APIKey等认证信息

### 2. 了解API特性

- 科大讯飞语音听写（流式版）WebAPI支持1分钟内的即时语音转文字技术
- 该接口通过WebSocket API方式提供服务，支持实时返回识别结果
- 官方文档地址：https://www.xfyun.cn/doc/asr/voicedictation/API.html

## 二、Flutter项目配置

### 1. 添加依赖

在 `pubspec.yaml`文件中添加以下依赖：

```yaml
dependencies:
  ifly_speech_recognition: ^1.0.5  # 基于科大讯飞语音听写WebAPI的Flutter插件 
  flutter_sound: ^9.2.3  # 用于录音功能 
  web_socket_channel: ^2.1.0  # WebSocket通信
```

### 2. Web项目特殊配置

在 `web/index.html`中添加必要的权限和配置：

```html
<script>
  // 检查浏览器是否支持录音
  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
    console.log('浏览器支持录音功能');
  } else {
    console.warn('浏览器不支持录音功能');
  }
</script>
```

## 三、API集成实现

### 1. 初始化语音识别服务

```dart
import 'package:ifly_speech_recognition/ifly_speech_recognition.dart';

class SpeechRecognitionService {
  final String appId;
  final String apiSecret;
  final String apiKey;
  
  SpeechRecognitionService({
    required this.appId,
    required this.apiSecret,
    required this.apiKey,
  });

  Future<void> init() async {
    // 初始化科大讯飞语音识别
    await IflySpeechRecognition.init(
      appId: appId,
      apiSecret: apiSecret,
      apiKey: apiKey,
    );
  }
}
```

### 2. 录音和识别实现

```dart
import 'package:flutter_sound/flutter_sound.dart';
import 'dart:convert';
import 'package:web_socket_channel/web_socket_channel.dart';

class VoiceRecognizer {
  FlutterSoundRecorder? _recorder;
  WebSocketChannel? _channel;
  bool _isRecording = false;
  
  Future<void> startRecording() async {
    // 初始化录音器
    _recorder = FlutterSoundRecorder();
    await _recorder!.openRecorder();
  
    // 连接WebSocket
    _channel = WebSocketChannel.connect(
      Uri.parse('wss://ws-api.xfyun.cn/v2/iat'),
    );
  
    // 开始录音
    await _recorder!.startRecorder(
      toFile: 'temp_recording.pcm',
      codec: Codec.pcm16,
      sampleRate: 16000,
    );
  
    _isRecording = true;
  
    // 定时发送音频数据
    _sendAudioData();
  }
  
  void _sendAudioData() {
    // 这里需要实现音频数据读取和发送逻辑
    // 参考科大讯飞WebAPI文档的音频格式要求 
  }
  
  Future<void> stopRecording() async {
    if (_isRecording) {
      await _recorder!.stopRecorder();
      await _channel!.sink.close();
      _isRecording = false;
    }
  }
}
```

## 四、完整示例代码

### 1. 主要业务逻辑

```dart
class SpeechRecognitionPage extends StatefulWidget {
  @override
  _SpeechRecognitionPageState createState() => _SpeechRecognitionPageState();
}

class _SpeechRecognitionPageState extends State<SpeechRecognitionPage> {
  String _resultText = '';
  bool _isListening = false;
  final SpeechRecognitionService _speechService = 
      SpeechRecognitionService(
        appId: 'YOUR_APP_ID',
        apiSecret: 'YOUR_API_SECRET', 
        apiKey: 'YOUR_API_KEY',
      );

  @override
  void initState() {
    super.initState();
    _initSpeechService();
  }

  Future<void> _initSpeechService() async {
    try {
      await _speechService.init();
    } catch (e) {
      print('初始化失败: $e');
    }
  }

  Future<void> _startListening() async {
    try {
      setState(() {
        _isListening = true;
        _resultText = '正在聆听...';
      });
    
      // 开始语音识别
      final result = await IflySpeechRecognition.startListening(
        timeout: 60, // 60秒超时 
        language: 'zh_cn', // 中文
        accent: 'mandarin', // 普通话
      );
    
      setState(() {
        _resultText = result ?? '识别失败';
        _isListening = false;
      });
    } catch (e) {
      setState(() {
        _resultText = '错误: $e';
        _isListening = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('语音识别')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(
              _resultText,
              style: TextStyle(fontSize: 20),
              textAlign: TextAlign.center,
            ),
            SizedBox(height: 40),
            ElevatedButton(
              onPressed: _isListening ? null : _startListening,
              child: Text(_isListening ? '聆听中...' : '开始说话'),
              style: ElevatedButton.styleFrom(
                minimumSize: Size(200, 60),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

## 五、注意事项

### 1. 平台兼容性

- `ifly_speech_recognition`插件主要支持移动端，Web端需要额外处理浏览器兼容性
- Web端需要确保浏览器支持Web Audio API和WebSocket

### 2. 音频格式要求

- 采样率必须为16000Hz
- 音频格式通常为PCM或WAV格式
- 单次识别时长不超过60秒

### 3. 权限处理

- Web端需要用户授权麦克风权限
- 在Flutter web中，需要在页面加载时请求权限

### 4. 错误处理

- 网络连接中断处理
- 音频数据格式错误处理
- API调用频率限制处理

## 六、参考资源

1. **官方文档**：https://www.xfyun.cn/doc/asr/voicedictation/API.html
2. **Flutter示例项目**：https://github.com/xiaobug0929/xf_demo
3. **WebSocket集成示例**：参考科大讯飞WebAPI示例demo
4. **Flutter插件文档**：https://pub.dev/packages/ifly_speech_recognition

## 七、调试建议

1. **先在移动端测试**：确保基础功能正常工作
2. **使用浏览器开发者工具**：监控WebSocket连接和音频数据
3. **分步调试**：先测试录音功能，再测试WebSocket连接，最后测试完整识别流程
4. **查看API返回状态码**：根据科大讯飞文档中的错误码进行问题定位

这份说明涵盖了在Flutter web页面上集成科大讯飞语音识别API的主要步骤和注意事项。建议您先参考官方文档和示例项目，根据实际需求进行调整和优化。

# 智谱（GLM）搜索API使用说明 - Flutter Web集成

## 1. 概述

智谱AI开放平台提供了Web Search API，这是一个专为大模型设计的搜索引擎，在传统搜索引擎网页抓取、排序的能力基础上，增强了意图识别能力，返回更适合大模型处理的结果（网页标题、网页URL、网页摘要等）。

## 2. 准备工作

### 2.1 注册账号和获取API Key

1. 访问智谱AI开放平台官网：https://bigmodel.cn
2. 点击右上角的「注册/登录」完成账号注册
3. 登录后进入「个人中心」-「项目管理」-「API keys」
4. 点击「添加新的API Key」，然后复制生成的API Key

**注意**：为了安全起见，建议每个应用或项目使用一个独立的API Key，而不是共享一个API Key。

### 2.2 套餐说明

- **仅Pro、Max套餐支持**：视觉理解、联网搜索MCP工具
- **Lite套餐**：调用视觉理解MCP需要单独收费，且暂未支持调用搜索工具
- **新用户福利**：注册即可获得一定免费额度的API调用资源

## 3. API调用基础

### 3.1 基础API端点

```
POST https://open.bigmodel.cn/api/paas/v4/chat/completions
```

### 3.2 请求头设置

```dart
headers: {
  'Content-Type': 'application/json',
  'Authorization': 'Bearer YOUR_API_KEY'
}
```

### 3.3 基础请求体格式

```json
{
  "model": "glm-4",  // 或 glm-4.5, glm-4.5-air 等
  "messages": [
    {
      "role": "user",
      "content": "你的问题"
    }
  ],
  "tools": [
    {
      "type": "web_search",
      "web_search": {
        "enable": true,
        "search_query": "搜索关键词"
      }
    }
  ]
}
```

## 4. Flutter Web集成示例

### 4.1 添加依赖

在 `pubspec.yaml`中添加：

```yaml
dependencies:
  http: ^1.1.0
  convert: ^3.1.1
```

### 4.2 完整的Flutter Web示例代码

```dart
import 'dart:convert';
import 'package:http/http.dart' as http;

class GLMApiService {
  final String apiKey;
  final String baseUrl = 'https://open.bigmodel.cn/api/paas/v4/chat/completions';
  
  GLMApiService(this.apiKey);

  Future<Map<String, dynamic>> searchWithGLM(String query) async {
    try {
      final response = await http.post(
        Uri.parse(baseUrl),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $apiKey',
        },
        body: json.encode({
          "model": "glm-4.5", // 推荐使用GLM-4.5，对工具调用进行了优化 
          "messages": [
            {
              "role": "user",
              "content": query
            }
          ],
          "tools": [
            {
              "type": "web_search",
              "web_search": {
                "enable": true,
                "search_query": query
              }
            }
          ],
          "stream": false, // 设置为true可启用流式输出
          "max_tokens": 1024,
          "temperature": 0.9
        }),
      );

      if (response.statusCode == 200) {
        return json.decode(response.body);
      } else {
        throw Exception('API请求失败: ${response.statusCode}, ${response.body}');
      }
    } catch (e) {
      throw Exception('请求异常: $e');
    }
  }
}

// Flutter Widget使用示例
import 'package:flutter/material.dart';

class SearchPage extends StatefulWidget {
  @override
  _SearchPageState createState() => _SearchPageState();
}

class _SearchPageState extends State<SearchPage> {
  final TextEditingController _controller = TextEditingController();
  String _result = '';
  bool _isLoading = false;
  
  // 替换为你的实际API Key
  final String _apiKey = 'your_api_key_here';
  final GLMApiService _apiService = GLMApiService('your_api_key_here');

  void _performSearch() async {
    setState(() {
      _isLoading = true;
      _result = '';
    });

    try {
      final result = await _apiService.searchWithGLM(_controller.text);
      // 解析响应结果
      final content = result['choices'][0]['message']['content'];
      setState(() {
        _result = content;
      });
    } catch (e) {
      setState(() {
        _result = '搜索失败: $e';
      });
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('智谱GLM搜索'),
      ),
      body: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          children: [
            TextField(
              controller: _controller,
              decoration: InputDecoration(
                hintText: '输入搜索内容...',
                suffixIcon: IconButton(
                  icon: Icon(Icons.search),
                  onPressed: _performSearch,
                ),
              ),
              onSubmitted: (_) => _performSearch(),
            ),
            SizedBox(height: 20),
            if (_isLoading)
              CircularProgressIndicator()
            else
              Expanded(
                child: SingleChildScrollView(
                  child: Text(
                    _result,
                    style: TextStyle(fontSize: 16),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
```

## 5. 高级功能和配置

### 5.1 流式输出支持

如果需要实时流式输出，可以设置 `"stream": true`，并使用WebSocket或SSE（Server-Sent Events）处理流式响应。

### 5.2 多轮对话支持

通过维护对话历史，可以实现多轮对话：

```dart
List<Map<String, dynamic>> _messages = [];

void addMessage(String role, String content) {
  _messages.add({
    "role": role,
    "content": content
  });
}

// 调用API时使用
"messages": _messages
```

### 5.3 工具调用优化

GLM-4.5和GLM-4.5-Air在工具调用、网页浏览、软件工程、前端编程领域进行了优化，推荐使用这些版本获得更好的搜索体验。

## 6. 响应格式说明

成功响应示例：

```json
{
  "id": "chatcmpl-xxx",
  "object": "chat.completion",
  "created": 1710000000,
  "model": "glm-4.5",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "搜索结果和回答内容",
        "tool_calls": [
          {
            "id": "call_xxx",
            "type": "web_search",
            "web_search": {
              "query": "搜索关键词",
              "results": [
                {
                  "title": "网页标题",
                  "url": "https://example.com",
                  "snippet": "网页摘要内容"
                }
              ]
            }
          }
        ]
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 10,
    "completion_tokens": 20,
    "total_tokens": 30
  }
}
```

## 7. 错误处理和注意事项

### 7.1 常见错误码

- `401 Unauthorized`: API Key无效或缺失
- `400 Bad Request`: 请求参数格式错误
- `429 Too Many Requests`: 超出调用频率限制
- `500 Internal Server Error`: 服务器内部错误

### 7.2 重要注意事项

1. **安全性**：在Flutter Web中，不要将API Key硬编码在前端代码中，建议通过后端代理或环境变量管理
2. **CORS问题**：在Web环境中，可能需要配置CORS（跨域资源共享）。如果遇到CORS问题，建议在后端创建代理API
3. **套餐限制**：联网搜索功能仅在Pro、Max套餐中可用，Lite套餐暂不支持搜索工具
4. **网络搜索启用**：语言模型默认启用web_search工具，如需禁用需要显式设置
5. **意图识别**：Web Search API返回的结果经过意图识别优化，更适合大模型处理

## 8. 最佳实践建议

1. **错误重试机制**：在网络不稳定时实现自动重试
2. **请求限流**：避免短时间内大量请求导致被限流
3. **缓存策略**：对相同查询结果进行缓存，减少API调用
4. **用户反馈**：提供搜索结果质量反馈机制
5. **监控统计**：记录API调用情况，监控使用量和成本

## 9. 参考资源

- 智谱AI开放平台官网：https://bigmodel.cn
- API文档中心：https://open.bigmodel.cn/dev/api
- React官方文档：https://react.dev/

通过以上配置，您可以在React构建的Web页面中成功集成智谱GLM的搜索API功能，为用户提供强大的AI搜索体验。

---

**重要说明**：本文档中关于Flutter Web的实现示例为原始技术选型参考。实际项目中前端已采用React + TypeScript + Vite技术栈，相关API集成已在React前端中实现。
